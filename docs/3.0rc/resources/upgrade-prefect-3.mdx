---
title: Upgrade to Prefect 3
description: Learn how to upgrade from Prefect 2 to Prefect 3.
---

Some patterns supported by Prefect 2 are no longer supported with Prefect 3, or are enabled differently. 
This guide covers changes that you may need to make to ensure your flows keep flowing.

## Module locations and names

Some modules have been renamed, reorganized, or removed for clarity. Objects imported from changed modules will continue to work until their deprecation period ends, but will raise deprecation warnings. 
You must update these modules before the six month deprecation period ends:

| Prefect 2 | Prefect 3 | Notes                                 |
| --------- | --------- | ------------------------------------- |
|           |           |                                       |

## Asynchronous task execution behavior

Prefect 2 abstracts away certain task execution concerns, which is convenient in some cases, but comes at the expense of unexpected behavior in other cases. 
Prefect 3 defaults to running tasks as they would run as normal Python code, and requires you to be more explicit when you would like to modify task execution behavior. 
This results in clearer behavior with fewer surprises.

In Prefect 3, all workflow code, including task functions, runs on the main thread. This means:

- Python code that is not explicitly defined as asynchronous will execute synchronously, as normal Python code does.
- Non-thread safe objects, such as database connections, can be shared globally within a workflow.

To execute tasks asynchronously in separate threads, you must either write asynchronous Python functions or use the `Task.submit` method. 
Prefect 3 encourages conventional asynchronous Python programing principles. 
Updating your workflows to bring them in line with these principles requires code changes. Here are some examples:

**Synchronous tasks and flows cannot be called from asynchronous tasks or flows as they could in Prefect 2.**

<CardGroup cols={2}>
  <Card title="Prefect 2">
    ```python
    @task
    async def my_task():
            ...
	

    # Enclosing flow can be sync
    @flow
    def my_flow():
	    return my_task()
	
		
    if __name__ == "__main__":
	    my_flow()
    ```
  </Card>
  <Card title="Prefect 3">
    ```python
    @task
    async def my_task():
	    ...
	

    # Enclosing flow must be async as well
    @flow
    async def my_flow():
	    return await my_task()
	
	
    if __name__ == "__main__":
	    asyncio.run(my_flow())
    ``` 
  </Card>
</CardGroup>

Because `Task.submit` is always a synchronous call, it does not need to be awaited. 
`Task.submit` is still non-blocking and execution of the submitted task is also still non-blocking. 
So, *you do not need to await futures from submitted tasks*:

<CardGroup cols={2}>
  <Card title="Prefect 2">
    ```python
    @task
    async def my_task():
	    ...
	
	
    @flow
    async def my_flow():
	    #must await `.submit()`
	    future = await my_task.submit()
	    return future
    ```
  </Card>
  <Card title="Prefect 3">
    ```python
    @task
    async def my_task():
	    ...
	
	
    @flow
    async def my_flow():
	    # No need to await `.submit()`
	    future = my_task.submit()
	    return future
    ```
  </Card>
</CardGroup>

The `PrefectFuture` methods are also always synchronous in Prefect 3. Names and return values have changed to reflect this:

- `PrefectFututure.get_state()` is now `PrefectFuture.state`
- `PrefectFuture.wait()` now returns `None` instead of a `State`

*Wait for the future to complete, then retrieve the state separately*:

<CardGroup cols={2}>
  <Card title="Prefect 2">
    ```python
    @task
    async def my_task():
    	    ...
	
	
    @flow
    async def my_flow():
    	future = await my_task.submit()
	    # State is returned by `wait()`
	    state = await future.wait()
	    return state
    ```
  </Card>
  <Card title="Prefect 3">
    ```python
    @task
    async def my_task():
    	    ...
	
	
    @flow
    async def my_flow():
	    future = my_task.submit()
	    # Wait for future completion  
	    # before retrieving the state
	    future.wait()
	    state = future.state
	    return state
    ```
  </Card>
</CardGroup>

In Prefect 3, `PrefectFutures` resulting from submitted task runs are not automatically awaited/resolved before exiting a flow, unless they’re a dependency of other flows or tasks, so *you must wait for a task’s `PrefectFuture` resolution before the end of a flow*:

<CardGroup cols={2}>
  <Card title="Prefect 2">
    ```python
    @task
    def my_task():
	    ...
	
	
    @flow
    def my_flow():
	    # The flow will not exit until these 
	    # futures are resolved
	    [my_task.submit() for i in range(10)]
    ```
  </Card>
  <Card title="Prefect 3">
    ```python
    @task
    def my_task():
	    ...
	
	
    @flow
    def my_flow():
	    futures = [my_task.submit() for i in range(10)]
	    # You must wait for futures before exiting flow.
	    futures.wait()
    ```
  </Card>
</CardGroup>

If you do not wait for the futures, the tasks may fail with a 'Flow must be running to start a task' error. 
The one exception to this case is that `PrefectFuture`s returned from a flow will resolve to states before completing the flow.

## Result persistence and caching behavior

Prefect 3 supports transactional semantics - tasks runs can be grouped into larger transactions, enabling more resilient, idempotent workflows. 
To support this, Prefect 3 has more eager, intelligent caching defaults than Prefect 2.

Whenever a task runs, Prefect 3 first computes its cache key, then uses that cache key to evaluate whether that same task has run with the same inputs and as part of the same flow before. 
If it has, the cached result from the previous run is used.
If it hasn't, the task runs. 
This behavior can be configured through the new global `cache_policy` setting, or through the `cache_key_fn` on the task, just as in Prefect 2.

Results and cache keys are not stored with your Prefect Cloud account or Prefect server instance. 
They are persisted entirely in your local result location. 
Result persistence, and the caching behavior it enables, can be disabled through the `persist_result=False` flag.

See the [caching documentation](/3.0rc/develop/write-tasks#caching) for more information.

## Notifications are now Automations

The notifications feature in Prefect 2 has been expanded to enable many kinds of “if this, then that” logic that can be defined and executed by a Prefect server instance or Prefect Cloud.
See the [Automations documentation](/3.0rc/automate/events/automations-triggers) for more information.

## Integrations must be upgraded

Integrations compatible with Prefect 2 generally cannot be used with Prefect 3 and vice versa. 
You must update all of your integrations packages in conjunction with upgrading from Prefect 2 to Prefect 3. 
We recommend specifying extras when you install the `prefect` package to ensure that you install the integration package version that corresponds to your Prefect version. For example, use `pip install prefect[aws] --pre` to install Prefect 3 and a compatible prefect-aws version.

## Data validation via Pydantic V2

Prefect 2 uses Pydantic V1 to validate data, particularly for blocks and work pools. 
Prefect 3 has been upgraded to Pydantic V2. This upgrade does not require changes for any built-in Prefect interfaces or supporting integrations. 
However, if you have registered custom blocks with a self-hosted Prefect Server, type enforcement for those block schemas must be upgraded to Pydantic V2 to work with Prefect 3. 
See the the [Pydantic migration guide](https://docs.pydantic.dev/latest/migration/) for more information.

## Workers have replaced Agents

A deprecation warning was applied to Prefect interfaces related to agent-based deployments in Prefect’s [2.16.4 release](https://github.com/PrefectHQ/prefect/releases/tag/2.16.4), including infrastructure blocks and `prefect deployment` commands. 
Agents will continue to be supported in Prefect 2 until September 2024, but have not been included in Prefect 3. 
If you are using agents, see [this guide to upgrade from agents to workers](https://docs-3.prefect.io/3.0rc/resources/upgrade-agents-to-workers).